<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dungeon Escape Duo</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #2c3e50;
            font-family: Arial, sans-serif;
        }
        
        /* Victory screen animations */
        @keyframes victory-pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .victory-animation {
            animation: victory-pulse 2s ease-in-out infinite;
        }
        
        @keyframes gradient-shift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        #game-container {
            text-align: center;
        }
        h1 {
            color: #ecf0f1;
            margin-bottom: 20px;
        }
        #status {
            color: #ecf0f1;
            margin-top: 20px;
            font-size: 16px;
            transition: all 0.3s ease; /* Smooth transitions for turn changes */
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <h1>Dungeon Escape Duo</h1>
        <div id="game"></div>
        <div id="status">Connecting to server...</div>
        <div id="item-display" style="text-align: center;"></div>
    </div>

    <!-- Phaser 3 Library via CDN -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    
    <!-- Socket.io Client Library -->
    <script src="/socket.io/socket.io.js"></script>
    
    <script>
        // Socket.io connection
        const socket = io();
        
        // Game state received from server
        let serverGameState = null;
        let myPlayerId = null;
        let gameInitialized = false;
        let connectionRejected = false;
        
        // Grid configuration
        const TILE_SIZE = 50;
        
        // References to game objects
        let gameScene = null;
        let playerSprites = {};
        let gridTiles = []; // Track grid tiles for clearing
        let tilemapLayers = []; // Track tilemap layers
        let currentTilemap = null; // Current tilemap instance
        let statusElement = document.getElementById('status');
        let itemDisplayElement = document.getElementById('item-display');
        
        // Tilemap tile ID to game logic mapping
        // Based on careful analysis of the Cardinal Zebra tileset and layer data
        const TILEMAP_TO_LOGIC = {
            // Walls (gray brick tiles from the tileset)
            1: 1, 5: 1, 6: 1, 8: 1, 9: 1, 10: 1, 12: 1, 13: 1, 15: 1, 29: 1, 30: 1, 34: 1,
            // Floors (purple cracked floor tiles)  
            16: 0, 17: 0, 18: 0, 19: 0, 23: 0, 25: 0, 26: 0,
            // Fire hazards (torch tiles) - from Layer 2
            7: 2,  // Torch tiles
            2: 2,  // Alternative torch tile
            // Chasms/water (barrel/pot tiles) - from Layer 2
            41: 3, 42: 3,  // Barrel/pot tiles that represent chasms
            // Floor tiles that were mistakenly identified as chasms
            43: 0, 44: 0,  // These are actually floor tiles, not chasms
            // Exit (chest/door tile) - from Layer 2
            49: 4,
            // Empty tiles (voids) become walls - impassable black space
            0: 1
        };
        
        // Reverse mapping for logic to tilemap rendering
        const LOGIC_TO_TILEMAP = {
            0: 16, // Floor -> basic floor tile
            1: 1,  // Wall -> basic wall tile
            2: 7,  // Fire -> fire tile
            3: 41, // Chasm -> water tile
            4: 49  // Exit -> special tile
        };
        
        // Socket event handlers
        socket.on('connect', () => {
            console.log('Connected to server');
            statusElement.textContent = 'Connected! Waiting for game state...';
        });
        
        socket.on('disconnect', () => {
            console.log('Disconnected from server');
            if (!connectionRejected) {
                statusElement.textContent = 'Disconnected from server';
            }
        });
        
        socket.on('connectionRejected', (data) => {
            console.log('Connection rejected:', data.reason);
            connectionRejected = true;
            statusElement.textContent = `Connection rejected: ${data.reason}`;
            statusElement.style.color = '#e74c3c'; // Red color for error
        });
        
        socket.on('gameState', (newGameState) => {
            try {
                const gameStateTimestamp = Date.now();
                console.log(`üì° [${gameStateTimestamp}] Received game state from server:`, newGameState);
                
                // Debug: Log if this game state contains any player movements
                if (serverGameState && newGameState.players) {
                    for (const [playerId, newPlayer] of Object.entries(newGameState.players)) {
                        const oldPlayer = serverGameState.players?.[playerId];
                        if (oldPlayer && (oldPlayer.x !== newPlayer.x || oldPlayer.y !== newPlayer.y)) {
                            console.log(`üì° [${gameStateTimestamp}] üö∂ ${playerId} moved from (${oldPlayer.x},${oldPlayer.y}) to (${newPlayer.x},${newPlayer.y}) - direction: ${newPlayer.lastMoveDirection}`);
                        }
                    }
                }
                
                // Validate game state structure
                if (!newGameState || typeof newGameState !== 'object') {
                    console.error('‚ùå Invalid game state received:', newGameState);
                    statusElement.textContent = '‚ùå Connection error - invalid game state';
                    statusElement.style.color = '#e74c3c';
                    return;
                }
                
                // Store the new game state
                serverGameState = newGameState;
            
            // If this is the initial game state, store our player ID
            if (newGameState.yourPlayerId) {
                myPlayerId = newGameState.yourPlayerId;
                console.log('Assigned as:', myPlayerId);
            }
            
                         // Update status
             const playerCount = Object.keys(newGameState.players).length;
             
                           // Check for level transition first
              if (newGameState.levelTransition && newGameState.levelTransition.isTransitioning) {
                  const toLevel = newGameState.levelTransition.toLevel;
                  statusElement.textContent = `üöÄ ENTERING LEVEL ${toLevel} üöÄ`;
                  statusElement.style.color = '#3498db'; // Blue for transition
                  statusElement.style.fontSize = '24px';
                  statusElement.style.fontWeight = 'bold';
                  statusElement.style.textShadow = '0 0 20px rgba(52, 152, 219, 0.8)'; // Blue glow
                  statusElement.style.textAlign = 'center';
                  statusElement.className = 'victory-animation'; // Reuse pulsing animation
                  
                  itemDisplayElement.textContent = `üéØ Prepare for greater challenges! New puzzles await... üéØ`;
                  itemDisplayElement.style.color = '#9b59b6'; // Purple for mystery
                  itemDisplayElement.style.fontSize = '16px';
                  itemDisplayElement.style.fontWeight = 'bold';
                  itemDisplayElement.style.textAlign = 'center';
                  
                  // Add transition background effect
                  document.getElementById('game-container').style.background = 'linear-gradient(45deg, #3498db, #9b59b6, #3498db)';
                  document.getElementById('game-container').style.backgroundSize = '300% 300%';
                  document.getElementById('game-container').style.animation = 'gradient-shift 2s ease infinite';
                  
              // Check for final game completion
              } else if (newGameState.gameCompleted) {
                  // Final victory - game completely finished!
                  statusElement.textContent = `üèÜ DUNGEON ESCAPE DUO MASTERED! üèÜ`;
                  itemDisplayElement.textContent = `üéâ PERFECT TEAMWORK! You conquered all levels together! üéâ | Refresh to play again`;
                  
                  statusElement.style.color = '#ff6b35'; // Bright orange-red for ultimate victory
                  statusElement.style.fontSize = '24px';
                  statusElement.style.fontWeight = 'bold';
                  statusElement.style.textShadow = '0 0 20px rgba(255, 107, 53, 0.9)'; // Bright glow
                  statusElement.style.textAlign = 'center';
                  statusElement.className = 'victory-animation'; // Add pulsing animation
                  
                  itemDisplayElement.style.color = '#d35400'; // Dark orange for contrast
                  itemDisplayElement.style.fontSize = '18px';
                  itemDisplayElement.style.fontWeight = 'bold';
                  itemDisplayElement.style.textAlign = 'center';
                  
                  // Add epic final victory effect to the game container
                  document.getElementById('game-container').style.background = 'linear-gradient(45deg, #e74c3c, #f39c12, #e67e22, #e74c3c)';
                  document.getElementById('game-container').style.backgroundSize = '400% 400%';
                  document.getElementById('game-container').style.animation = 'gradient-shift 1.5s ease infinite';
                  
              // Check for level completion (but not final game completion)
              } else if (newGameState.gameWon) {
                  // Create victory display for level completion
                  const levelName = newGameState.levelProgression === 1 ? "Level 1" : "Level 2";
                  
                  statusElement.textContent = `üéâ VICTORY! ${levelName.toUpperCase()} COMPLETE! üéâ`;
                  itemDisplayElement.textContent = `üåü Excellent teamwork! Advancing to Level 2 in 5 seconds... üåü`;
                  
                  statusElement.style.color = '#f1c40f'; // Golden yellow for victory
                  statusElement.style.fontSize = '22px';
                  statusElement.style.fontWeight = 'bold';
                  statusElement.style.textShadow = '0 0 15px rgba(241, 196, 15, 0.8)'; // Golden glow
                  statusElement.style.textAlign = 'center';
                  statusElement.className = 'victory-animation'; // Add pulsing animation
                  
                  itemDisplayElement.style.color = '#27ae60'; // Green for celebration
                  itemDisplayElement.style.fontSize = '16px';
                  itemDisplayElement.style.fontWeight = 'bold';
                  itemDisplayElement.style.textAlign = 'center';
                  
                  // Add celebration confetti effect to the game container
                  document.getElementById('game-container').style.background = 'linear-gradient(45deg, #2c3e50, #34495e, #2c3e50)';
                  document.getElementById('game-container').style.backgroundSize = '200% 200%';
                  document.getElementById('game-container').style.animation = 'gradient-shift 3s ease infinite';
                            } else if (playerCount === 1) {
                  // Check if there was a disconnection vs fresh start
                  if (newGameState.disconnectedPlayer) {
                      const disconnectedPlayerId = newGameState.disconnectedPlayer.playerId.toUpperCase();
                      statusElement.textContent = `‚ö†Ô∏è ${disconnectedPlayerId} disconnected! Waiting for reconnection... You are ${myPlayerId}`;
                      statusElement.style.color = '#e74c3c'; // Red for disconnection
                      itemDisplayElement.textContent = `Game paused at Level ${newGameState.levelProgression} | ${disconnectedPlayerId} has 30 seconds to reconnect`;
                  } else {
                      statusElement.textContent = `‚è≥ Waiting for partner to join... You are ${myPlayerId}`;
                      statusElement.style.color = '#f39c12'; // Orange for waiting
                      itemDisplayElement.textContent = `Level ${newGameState.levelProgression} - ${newGameState.currentLevel.toUpperCase()} Layout ${newGameState.mapIndex + 1} | Partner needed to continue`;
                  }
                  
                  statusElement.style.fontSize = '18px';
                  statusElement.style.fontWeight = 'bold';
                  statusElement.className = ''; // Remove any victory animations
                  statusElement.style.textShadow = 'none';
                  itemDisplayElement.style.color = statusElement.style.color;
                  
                  // Reset background for non-victory states
                  document.getElementById('game-container').style.background = 'none';
                  document.getElementById('game-container').style.animation = 'none';
             } else if (playerCount === 2) {
                 if (newGameState.gameStarted) {
                     const isMyTurn = newGameState.currentPlayerTurn === myPlayerId;
                     
                     if (isMyTurn) {
                         statusElement.textContent = `üü¢ YOUR TURN | You are ${myPlayerId} | Arrow keys: move, SPACE: use item`;
                         statusElement.style.color = '#2ecc71'; // Bright green for your turn
                         statusElement.style.fontSize = '18px';
                         statusElement.style.fontWeight = 'bold';
                         statusElement.style.textShadow = '0 0 10px rgba(46, 204, 113, 0.5)'; // Subtle glow effect
                     } else {
                         const otherPlayer = newGameState.currentPlayerTurn.toUpperCase();
                         statusElement.textContent = `‚è≥ ${otherPlayer}'S TURN | You are ${myPlayerId} | Wait for your partner...`;
                         statusElement.style.color = '#f39c12'; // Orange for waiting
                                               statusElement.style.fontSize = '16px';
                      statusElement.style.fontWeight = 'normal';
                      statusElement.style.textShadow = 'none';
                      statusElement.className = ''; // Remove victory animations
                     }
                     
                     // Update item display
                     if (newGameState.yourItem) {
                         itemDisplayElement.textContent = `Your Item: ${newGameState.yourItem} | Level ${newGameState.levelProgression} - ${newGameState.currentLevel.toUpperCase()} Layout ${newGameState.mapIndex + 1}`;
                         itemDisplayElement.style.color = '#3498db'; // Blue for item
                     } else {
                         itemDisplayElement.textContent = `Level ${newGameState.levelProgression} - ${newGameState.currentLevel.toUpperCase()} Layout ${newGameState.mapIndex + 1}`;
                         itemDisplayElement.style.color = '#95a5a6'; // Grey for map info
                     }
                 } else {
                     statusElement.textContent = `üöÄ Both players ready! You are ${myPlayerId}. Game starting...`;
                                           statusElement.style.color = '#2ecc71'; // Green for ready
                      statusElement.style.fontSize = '18px';
                      statusElement.style.fontWeight = 'bold';
                      statusElement.className = ''; // Remove victory animations
                      statusElement.style.textShadow = 'none';
                      itemDisplayElement.textContent = `Level ${newGameState.levelProgression} - ${newGameState.currentLevel.toUpperCase()} Layout ${newGameState.mapIndex + 1} | Get ready to cooperate!`;
                      itemDisplayElement.style.color = '#2ecc71';
                      
                      // Reset background for normal game states
                      document.getElementById('game-container').style.background = 'none';
                      document.getElementById('game-container').style.animation = 'none';
                 }
             }
            
                // Initialize or update the game rendering
                if (gameInitialized && gameScene) {
                    updateGameRendering();
                } else if (!gameInitialized && newGameState.dungeonLayout) {
                    initializeGame();
                }
                
            } catch (gameStateError) {
                console.error('‚ùå Error processing game state:', gameStateError);
                statusElement.textContent = '‚ùå Game rendering error - please refresh';
                statusElement.style.color = '#e74c3c';
            }
        });

        // Handle game errors from server
        socket.on('gameError', (errorData) => {
            console.error('‚ùå Game error from server:', errorData);
            statusElement.textContent = `‚ùå Game Error: ${errorData.message}`;
            statusElement.style.color = '#e74c3c';
            statusElement.style.fontSize = '16px';
            statusElement.style.fontWeight = 'bold';
        });

        // Phaser 3 Game Configuration
        const config = {
            type: Phaser.AUTO,
            width: 800,
            height: 600,
            parent: 'game',
            backgroundColor: '#000000', // Black background outside map
            scene: {
                preload: preload,
                create: create,
                update: update
            },
            render: {
                pixelArt: true, // Prevent blurring on pixel art
                antialias: false
            }
        };

        // Phaser 3 Scene Functions
        function preload() {
            console.log('üéÆ Loading game assets...');
            
            // Load tileset and tilemap
            this.load.image('tiles', 'assets/Full.png');
            this.load.tilemapTiledJSON('level1', 'assets/level1.tmj');
            
            // Load player character sprite sheets
            console.log('üèÉ Loading character sprite sheets...');
            this.load.spritesheet('soldier', 'assets/soldier.png', { 
                frameWidth: 64, 
                frameHeight: 64 
            });
            this.load.spritesheet('orc', 'assets/orc.png', { 
                frameWidth: 64, 
                frameHeight: 64 
            });
            
            // Keep loading individual tiles as backup for fallback mode
            this.load.image('floor', 'assets/tiles/floor.png');
            this.load.image('wall', 'assets/tiles/wall.png');
            this.load.image('fire', 'assets/tiles/fire.png');
            this.load.image('water', 'assets/tiles/water.png');
            this.load.image('exit', 'assets/tiles/exit.png');
            
            // Add error handling for failed loads
            this.load.on('loaderror', (file) => {
                console.error(`‚ùå Failed to load: ${file.key} from ${file.url}`);
            });
            
            this.load.on('complete', () => {
                console.log('‚úÖ All assets loaded successfully');
            });
        }

        function create() {
            gameScene = this;
            
            // Create character animations
            createCharacterAnimations(this);
            
            // Set up keyboard input
            setupKeyboardInput(this);
            
            // If we already have game state, render it
            if (serverGameState) {
                renderInitialGame();
            }
        }

        function createCharacterAnimations(scene) {
            console.log('üé≠ Creating character animations...');
            
            // Soldier (Player 1) animations
            if (scene.textures.exists('soldier')) {
                // TEST: Walking animation using just frame 0 (idle) to test movement issue
                scene.anims.create({
                    key: 'soldier-walk',
                    frames: scene.anims.generateFrameNumbers('soldier', { start: 0, end: 0 }),
                    frameRate: 8,
                    repeat: -1
                });
                
                console.log('‚úÖ Soldier animations created (TEST: using frame 0 only)');
            } else {
                console.warn('‚ö†Ô∏è Soldier sprite sheet not loaded, skipping animations');
            }
            
            // Orc (Player 2) animations  
            if (scene.textures.exists('orc')) {
                // TEST: Walking animation using just frame 0 (idle) to test movement issue
                scene.anims.create({
                    key: 'orc-walk',
                    frames: scene.anims.generateFrameNumbers('orc', { start: 0, end: 0 }),
                    frameRate: 8,
                    repeat: -1
                });
                
                console.log('‚úÖ Orc animations created (TEST: using frame 0 only)');
            } else {
                console.warn('‚ö†Ô∏è Orc sprite sheet not loaded, skipping animations');
            }
        }

        function initializeGame() {
            if (!serverGameState || gameInitialized) return;
            
            console.log('Initializing game with server state');
            gameInitialized = true;
            
            // If the Phaser scene is ready, render immediately
            if (gameScene) {
                renderInitialGame();
            }
        }

        function renderInitialGame() {
            if (!gameScene || !serverGameState) return;
            
            // Clear any existing game objects
            gameScene.children.removeAll();
            playerSprites = {};
            gridTiles = []; // Clear grid tiles array
            tilemapLayers = []; // Clear tilemap layers
            currentTilemap = null; // Clear current tilemap
            
            // Try to render using tilemap first, fallback to grid if it fails
            if (!renderTilemap()) {
                console.log('Tilemap rendering failed, falling back to grid rendering');
                renderDungeonGrid();
            }
            
            // Create player sprites
            createPlayerSprites();
            
            // Update status
            updateGameRendering();
        }

        function renderDungeonGrid() {
            try {
                if (!gameScene || !serverGameState) {
                    console.warn('‚ö†Ô∏è  Cannot render grid: missing scene or game state');
                    return;
                }
                
                if (!serverGameState.dungeonLayout || !Array.isArray(serverGameState.dungeonLayout)) {
                    console.error('‚ùå Invalid dungeon layout:', serverGameState.dungeonLayout);
                    return;
                }
            
            // Clear existing grid tiles
            gridTiles.forEach(tile => tile.destroy());
            gridTiles = [];
            
            const dungeonLayout = serverGameState.dungeonLayout;
            const gridWidth = serverGameState.gridWidth;
            const gridHeight = serverGameState.gridHeight;
            
            // Calculate starting position to center the grid
            const startX = (800 - (gridWidth * TILE_SIZE)) / 2;
            const startY = (600 - (gridHeight * TILE_SIZE)) / 2;
            
            // Loop through each row
            for (let row = 0; row < gridHeight; row++) {
                // Loop through each column
                for (let col = 0; col < gridWidth; col++) {
                    // Get the tile type from the dungeon layout
                    const tileType = dungeonLayout[row][col];
                    
                    // Calculate pixel position for sprite (centered)
                    const x = startX + (col * TILE_SIZE) + (TILE_SIZE / 2);
                    const y = startY + (row * TILE_SIZE) + (TILE_SIZE / 2);
                    
                    // Choose sprite based on tile type
                    let spriteKey;
                    if (tileType === 0) {
                        spriteKey = 'floor'; // Floor tiles
                    } else if (tileType === 1) {
                        spriteKey = 'wall'; // Wall tiles
                    } else if (tileType === 2) {
                        spriteKey = 'fire'; // Fire hazard
                    } else if (tileType === 3) {
                        spriteKey = 'water'; // Water/chasm hazard
                    } else if (tileType === 4) {
                        spriteKey = 'exit'; // Exit tiles
                    }
                    
                    // Create a sprite for this tile with fallback to colored rectangles
                    let tile;
                    try {
                        // Try to create sprite first
                        tile = gameScene.add.image(x, y, spriteKey);
                        
                        // Scale the sprite to fit our tile size (32x32 tileset -> 50px tiles)
                        const scale = TILE_SIZE / 32; // Scale factor from 32px to TILE_SIZE
                        tile.setScale(scale);
                    } catch (error) {
                        // Fallback to colored rectangles if sprites not loaded
                        console.log(`Sprite '${spriteKey}' not found, using colored rectangle fallback`);
                        
                        // Fallback colors (same as before)
                        let color;
                        if (tileType === 0) color = 0x95a5a6; // Light grey for floor
                        else if (tileType === 1) color = 0x2c3e50; // Dark grey for walls
                        else if (tileType === 2) color = 0xe74c3c; // Red for fire
                        else if (tileType === 3) color = 0x8e44ad; // Purple for water
                        else if (tileType === 4) color = 0x27ae60; // Green for exit
                        
                        // Create rectangle at top-left position (not centered)
                        const rectX = startX + (col * TILE_SIZE);
                        const rectY = startY + (row * TILE_SIZE);
                        tile = gameScene.add.rectangle(rectX, rectY, TILE_SIZE - 2, TILE_SIZE - 2, color);
                        tile.setOrigin(0, 0);
                    }
                    
                    gridTiles.push(tile); // Track for clearing later
                }
            }
            
            } catch (error) {
                console.error('‚ùå Error rendering dungeon grid:', error);
                statusElement.textContent = '‚ùå Rendering error - please refresh';
                statusElement.style.color = '#e74c3c';
            }
        }

        function renderTilemap() {
            try {
                if (!gameScene) {
                    console.warn('‚ö†Ô∏è  Cannot render tilemap: missing scene');
                    return false;
                }
                
                // Check if tileset image loaded
                if (!gameScene.textures.exists('tiles')) {
                    console.warn('‚ö†Ô∏è  Tileset image "tiles" not loaded');
                    return false;
                }
                
                // Try to create tilemap from loaded data
                const map = gameScene.make.tilemap({ key: 'level1' });
                if (!map) {
                    console.warn('‚ö†Ô∏è  Failed to create tilemap');
                    return false;
                }
                
                console.log(`üìã Tilemap created: ${map.width}x${map.height}, layers: ${map.layers.length}`);
                
                // Add tileset to the map - make sure the name matches the tileset name in the TMJ file
                const tileset = map.addTilesetImage('Full', 'tiles');
                if (!tileset) {
                    console.warn('‚ö†Ô∏è  Failed to add tileset to map');
                    console.log('Available tilesets in map:', map.tilesets.map(ts => ts.name));
                    return false;
                }
                
                console.log(`üé® Tileset added: ${tileset.name}, tiles: ${tileset.total}`);
                
                // Create layers from tilemap
                const backgroundLayer = map.createLayer('Tile Layer 1', tileset);
                const middleLayer = map.createLayer('Tile Layer 2', tileset);
                const foregroundLayer = map.createLayer('Tile Layer 3', tileset);
                
                if (!backgroundLayer) {
                    console.warn('‚ö†Ô∏è  Failed to create tilemap layers');
                    return false;
                }
                
                console.log(`üé¨ Layers created: ${[backgroundLayer, middleLayer, foregroundLayer].filter(l => l).length} total`);
                
                // Store references for cleanup
                currentTilemap = map;
                tilemapLayers = [backgroundLayer, middleLayer, foregroundLayer].filter(layer => layer);
                
                // Calculate scaling and positioning to fit game area
                const mapWidth = map.width * map.tileWidth;   // Should be 12 * 32 = 384px
                const mapHeight = map.height * map.tileHeight; // Should be 9 * 32 = 288px
                
                console.log(`Map dimensions: ${map.width}x${map.height} tiles, ${mapWidth}x${mapHeight} pixels`);
                
                // Target area (leave space for status)
                const targetWidth = 800;
                const targetHeight = 580; // Leave small space for status at bottom
                
                // Calculate scale to fit
                const scaleX = targetWidth / mapWidth;
                const scaleY = targetHeight / mapHeight;
                const scale = Math.min(scaleX, scaleY); // Use smaller scale to maintain aspect ratio
                
                // Position tilemap in center
                const offsetX = (800 - (mapWidth * scale)) / 2;
                const offsetY = (600 - (mapHeight * scale)) / 2; // Center vertically in full canvas
                
                console.log(`Scaling: ${scale}, Position: (${offsetX}, ${offsetY})`);
                console.log(`Scaled size: ${mapWidth * scale}x${mapHeight * scale}`);
                
                // Apply scaling and positioning to all layers
                tilemapLayers.forEach(layer => {
                    layer.setScale(scale);
                    layer.setPosition(offsetX, offsetY);
                });
                
                console.log(`‚úÖ Tilemap rendered successfully (${map.width}x${map.height}, scale: ${scale.toFixed(2)})`);
                
                // Update tilemap to match server game state (not the other way around!)
                // DISABLED: This overwrites the nice tilemap visuals with basic tiles
                /*if (serverGameState && serverGameState.dungeonLayout) {
                    updateTilemapFromGameState(map);
                }*/
                
                return true;
                
            } catch (error) {
                console.error('‚ùå Error rendering tilemap:', error);
                return false;
            }
        }

        function updateTilemapFromGameState(map) {
            try {
                console.log('üîÑ Updating tilemap to match server game state...');
                
                // Update tilemap tiles to match server's parsed game state
                const serverLayout = serverGameState.dungeonLayout;
                const layer = tilemapLayers[0]; // Use first layer for updates
                
                if (!layer || !serverLayout) {
                    console.warn('‚ö†Ô∏è Cannot update tilemap: missing layer or server layout');
                    return;
                }
                
                // Update each tile in the tilemap to match server logic
                for (let y = 0; y < serverGameState.gridHeight; y++) {
                    for (let x = 0; x < serverGameState.gridWidth; x++) {
                        if (y < serverLayout.length && x < serverLayout[y].length) {
                            const logicType = serverLayout[y][x];
                            const tileId = LOGIC_TO_TILEMAP[logicType] || 16; // Default to floor
                            
                            // Set the tile in the tilemap
                            layer.putTileAt(tileId, x, y);
                        }
                    }
                }
                
                console.log(`‚úÖ Updated tilemap tiles to match server state (${serverGameState.gridWidth}x${serverGameState.gridHeight})`);
                console.log('üîç Server layout preview:');
                for (let y = 0; y < Math.min(serverGameState.gridHeight, 5); y++) {
                    let row = '';
                    for (let x = 0; x < Math.min(serverGameState.gridWidth, 15); x++) {
                        const tile = serverLayout[y][x];
                        row += tile === 0 ? '.' : tile === 1 ? '#' : tile === 2 ? 'F' : tile === 3 ? 'W' : tile === 4 ? 'E' : '?';
                    }
                    console.log(`Row ${y}: ${row}`);
                }
                
            } catch (error) {
                console.error('‚ùå Error updating tilemap from game state:', error);
            }
        }

        function createPlayerSprites() {
            if (!gameScene || !serverGameState) return;
            
            // Create sprites for all players
            for (const [playerId, player] of Object.entries(serverGameState.players)) {
                const coords = getTilePixelPosition(player.x, player.y);
                
                // Determine sprite key and animations based on player
                let spriteKey, walkAnim;
                if (playerId === 'player1') {
                    spriteKey = 'soldier';
                    walkAnim = 'soldier-walk';
                } else {
                    spriteKey = 'orc';
                    walkAnim = 'orc-walk';
                }
                
                // Try to create animated sprite, fallback to rectangle if sprite not available
                let sprite;
                if (gameScene.textures.exists(spriteKey)) {
                    // Create animated sprite at tile center
                    sprite = gameScene.add.sprite(coords.x, coords.y, spriteKey);
                    
                    // Set origin to center
                    sprite.setOrigin(0.5, 0.5);
                    
                    // Scale the sprite to fit the tile size (64x64 sprite -> tile size)
                    const scale = (coords.tileSize * 2.0) / 64; // Use 200% of tile size for better visibility
                    sprite.setScale(scale);
                    sprite.setDepth(100);
                    
                    // Set to idle frame (frame 0) - character will be still
                    sprite.setFrame(0);
                    
                    // Store animation references for state management
                    sprite.walkAnim = walkAnim;
                    sprite.isWalking = false;
                    
                    // Store initial tile coordinates to prevent walking animation on first render
                    sprite.lastTileX = player.x;
                    sprite.lastTileY = player.y;
                    
                    // Ensure sprite starts with no tint and proper flip state
                    sprite.clearTint();
                    
                    // Initialize flip state based on starting direction (if any)
                    if (player.lastMoveDirection === 'left') {
                        sprite.setFlipX(true);
                    } else {
                        sprite.setFlipX(false); // Default to facing right
                    }
                    
                    // MANUAL OFFSET: Adjust sprite position to center character properly on tile
                    // The character artwork appears to be positioned at bottom-right of sprite frame
                    const offsetY = -20 * scale; // Move up to center vertically
                    
                    // Adjust horizontal offset based on flip state
                    let offsetX;
                    if (sprite.flipX) {
                        // When flipped (facing left), offset needs to be positive to center properly
                        offsetX = 16 * scale; // Move right to center horizontally
                    } else {
                        // When not flipped (facing right), use negative offset as before
                        offsetX = -16 * scale; // Move left to center horizontally
                    }
                    
                    sprite.setPosition(coords.x + offsetX, coords.y + offsetY);
                    
                    console.log(`‚úÖ Positioned ${playerId} sprite with offset (${offsetX.toFixed(1)}, ${offsetY.toFixed(1)}), flipX: ${sprite.flipX}`)
                    
                    console.log(`‚úÖ Created animated sprite for ${playerId} using ${spriteKey} (idle frame 0)`);
                } else {
                    // Fallback to colored rectangle
                    console.warn(`‚ö†Ô∏è Sprite '${spriteKey}' not available, using rectangle fallback for ${playerId}`);
                    const color = playerId === 'player1' ? 0x3498db : 0xe74c3c; // Blue for P1, Red for P2
                    sprite = gameScene.add.rectangle(coords.x, coords.y, coords.tileSize - 10, coords.tileSize - 10, color);
                    sprite.setStrokeStyle(2, 0xffffff);
                    sprite.setDepth(100);
                }
                
                playerSprites[playerId] = sprite;
                
                // Add label above tile center (not relative to offset sprite)
                const label = gameScene.add.text(coords.x, coords.y - 40, playerId.toUpperCase(), {
                    fontSize: '12px',
                    fill: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: 2
                }).setOrigin(0.5);
                label.setDepth(101);
                
                playerSprites[playerId + '_label'] = label;
            }
        }

        function getTilePixelPosition(tileX, tileY) {
            // If using tilemap, calculate position based on tilemap scaling
            if (currentTilemap && tilemapLayers.length > 0) {
                const layer = tilemapLayers[0]; // Use first layer for positioning reference
                const scale = layer.scaleX;
                const offsetX = layer.x;
                const offsetY = layer.y;
                
                // Position calculation for sprites
                
                // Ensure coordinates are within map bounds
                const clampedX = Math.max(0, Math.min(tileX, currentTilemap.width - 1));
                const clampedY = Math.max(0, Math.min(tileY, currentTilemap.height - 1));
                
                const pixelX = offsetX + (clampedX * currentTilemap.tileWidth * scale) + (currentTilemap.tileWidth * scale / 2);
                const pixelY = offsetY + (clampedY * currentTilemap.tileHeight * scale) + (currentTilemap.tileHeight * scale / 2);
                
                // Calculate final pixel position
                
                return {
                    x: pixelX,
                    y: pixelY,
                    tileSize: currentTilemap.tileWidth * scale
                };
            } else {
                // Fallback to original grid positioning
                const startX = (800 - (serverGameState.gridWidth * TILE_SIZE)) / 2;
                const startY = (600 - (serverGameState.gridHeight * TILE_SIZE)) / 2;
                
                return {
                    x: startX + (tileX * TILE_SIZE) + (TILE_SIZE / 2),
                    y: startY + (tileY * TILE_SIZE) + (TILE_SIZE / 2),
                    tileSize: TILE_SIZE
                };
            }
        }

        function updateTilemapTiles() {
            if (!currentTilemap || !tilemapLayers.length || !serverGameState.dungeonLayout) return;
            
            try {
                // Update tiles based on current game state
                for (let y = 0; y < serverGameState.gridHeight; y++) {
                    for (let x = 0; x < serverGameState.gridWidth; x++) {
                        if (y < serverGameState.dungeonLayout.length && x < serverGameState.dungeonLayout[y].length) {
                            const logicType = serverGameState.dungeonLayout[y][x];
                            const newTileId = LOGIC_TO_TILEMAP[logicType] || 16; // Default to floor
                            
                            // Update the tile in the appropriate layer (use first layer for game logic)
                            const layer = tilemapLayers[0];
                            if (layer) {
                                const currentTile = layer.getTileAt(x, y);
                                if (!currentTile || currentTile.index !== newTileId) {
                                    layer.putTileAt(newTileId, x, y);
                                }
                            }
                        }
                    }
                }
                
                console.log('üîÑ Updated tilemap tiles from game state');
                
            } catch (error) {
                console.error('‚ùå Error updating tilemap tiles:', error);
            }
        }

        function updateGameRendering() {
            if (!gameScene || !serverGameState) return;
            const renderTimestamp = Date.now();
            console.log(`üîÑ [${renderTimestamp}] updateGameRendering called - players: ${Object.keys(serverGameState.players).join(', ')}`);
            
            // Log player positions for debugging
            for (const [playerId, player] of Object.entries(serverGameState.players)) {
                console.log(`üîÑ [${renderTimestamp}] ${playerId} server position: (${player.x}, ${player.y}), lastMove: ${player.lastMoveDirection || 'none'}`);
            }
            
            // Update tilemap tiles if using tilemap system, otherwise re-render grid
            // DISABLED: Let the tilemap keep its original visual style
            /*if (currentTilemap && tilemapLayers.length > 0) {
                updateTilemapTiles();
            } else {*/
                // Re-render the entire grid to show tile changes (like fire being doused)
                // For now, don't update tilemap dynamically
            /*}*/
            
            // Check for new players and create sprites for them
            for (const [playerId, player] of Object.entries(serverGameState.players)) {
                if (!playerSprites[playerId]) {
                    // New player detected - create sprite and label using the main function
                    const coords = getTilePixelPosition(player.x, player.y);
                    
                    // Determine sprite key and animations based on player
                    let spriteKey, walkAnim;
                    if (playerId === 'player1') {
                        spriteKey = 'soldier';
                        walkAnim = 'soldier-walk';
                    } else {
                        spriteKey = 'orc';
                        walkAnim = 'orc-walk';
                    }
                    
                    // Try to create animated sprite, fallback to rectangle if sprite not available
                    let sprite;
                    if (gameScene.textures.exists(spriteKey)) {
                        // Create animated sprite at tile center
                        sprite = gameScene.add.sprite(coords.x, coords.y, spriteKey);
                        
                        // Set origin to center
                        sprite.setOrigin(0.5, 0.5);
                        
                        // Scale the sprite to fit the tile size (64x64 sprite -> tile size)
                        const scale = (coords.tileSize * 2.0) / 64; // Use 200% of tile size for better visibility
                        sprite.setScale(scale);
                        sprite.setDepth(100);
                        
                        // Set to idle frame (frame 0) - character will be still
                        sprite.setFrame(0);
                        
                        // Store animation references for state management
                        sprite.walkAnim = walkAnim;
                        sprite.isWalking = false;
                        
                        // Store initial tile coordinates to prevent walking animation on first render
                        sprite.lastTileX = player.x;
                        sprite.lastTileY = player.y;
                        
                        // Ensure sprite starts with no tint and proper flip state
                        sprite.clearTint();
                        
                        // Initialize flip state based on starting direction (if any)
                        if (player.lastMoveDirection === 'left') {
                            sprite.setFlipX(true);
                        } else {
                            sprite.setFlipX(false); // Default to facing right
                        }
                        
                        // MANUAL OFFSET: Adjust sprite position to center character properly on tile
                        // The character artwork appears to be positioned at bottom-right of sprite frame
                        const offsetY = -20 * scale; // Move up to center vertically
                        
                        // Adjust horizontal offset based on flip state
                        let offsetX;
                        if (sprite.flipX) {
                            // When flipped (facing left), offset needs to be positive to center properly
                            offsetX = 16 * scale; // Move right to center horizontally
                        } else {
                            // When not flipped (facing right), use negative offset as before
                            offsetX = -16 * scale; // Move left to center horizontally
                        }
                        
                        sprite.setPosition(coords.x + offsetX, coords.y + offsetY);
                        
                        console.log(`‚úÖ Positioned ${playerId} sprite with offset (${offsetX.toFixed(1)}, ${offsetY.toFixed(1)}), flipX: ${sprite.flipX}`)
                        
                        console.log(`‚úÖ Created animated sprite for ${playerId} using ${spriteKey} (idle frame 0)`);
                    } else {
                        // Fallback to colored rectangle
                        console.warn(`‚ö†Ô∏è Sprite '${spriteKey}' not available, using rectangle fallback for ${playerId}`);
                        const color = playerId === 'player1' ? 0x3498db : 0xe74c3c; // Blue for P1, Red for P2
                        sprite = gameScene.add.rectangle(coords.x, coords.y, coords.tileSize - 10, coords.tileSize - 10, color);
                        sprite.setStrokeStyle(2, 0xffffff);
                        sprite.setDepth(100);
                    }
                    
                    playerSprites[playerId] = sprite;
                    
                    // Add label above tile center (not relative to offset sprite)
                    const label = gameScene.add.text(coords.x, coords.y - 40, playerId.toUpperCase(), {
                        fontSize: '12px',
                        fill: '#ffffff',
                        stroke: '#000000',
                        strokeThickness: 2
                    }).setOrigin(0.5);
                    label.setDepth(101);
                    
                    playerSprites[playerId + '_label'] = label;
                    
                    console.log(`Created sprite for new player: ${playerId}`);
                }
            }
            
            // Remove sprites for players who have disconnected
            for (const spriteKey of Object.keys(playerSprites)) {
                if (spriteKey.endsWith('_label')) continue; // Skip labels, handle them with their player
                
                const playerId = spriteKey;
                if (!serverGameState.players[playerId]) {
                    // Player has disconnected - remove sprite and label
                    if (playerSprites[playerId]) {
                        playerSprites[playerId].destroy();
                        delete playerSprites[playerId];
                    }
                    if (playerSprites[playerId + '_label']) {
                        playerSprites[playerId + '_label'].destroy();
                        delete playerSprites[playerId + '_label'];
                    }
                    console.log(`Removed sprite for disconnected player: ${playerId}`);
                }
            }
            
            // Update positions for all existing players
            for (const [playerId, player] of Object.entries(serverGameState.players)) {
                const sprite = playerSprites[playerId];
                const label = playerSprites[playerId + '_label'];
                
                if (sprite && label) {
                    const coords = getTilePixelPosition(player.x, player.y);
                    
                    // Check if player position changed to trigger walking animation
                    // Compare previous tile coordinates to current tile coordinates
                    const oldTileX = sprite.lastTileX !== undefined ? sprite.lastTileX : player.x;
                    const oldTileY = sprite.lastTileY !== undefined ? sprite.lastTileY : player.y;
                    const positionChanged = (oldTileX !== player.x || oldTileY !== player.y);
                    
                    // Update stored tile coordinates for next comparison
                    sprite.lastTileX = player.x;
                    sprite.lastTileY = player.y;
                    
                    // Handle animation states and direction flipping for animated sprites
                    if (sprite.walkAnim) {
                        const timestamp = Date.now();
                        console.log(`üé¨ [${timestamp}] ${playerId} animation check: posChanged=${positionChanged}, isWalking=${sprite.isWalking}, oldTile=(${oldTileX},${oldTileY}), newTile=(${player.x},${player.y})`);
                        console.log(`üé¨ [${timestamp}] ${playerId} current animation state: playing=${sprite.anims.isPlaying}, currentAnim=${sprite.anims.currentAnim?.key || 'none'}, frame=${sprite.frame.name}`);
                        
                        if (positionChanged && !sprite.isWalking) {
                            console.log(`üé¨ [${timestamp}] üü¢ STARTING animation for ${playerId} - setting isWalking=true`);
                            // Start walking animation
                            sprite.play(sprite.walkAnim);
                            sprite.isWalking = true;
                            
                            // Store timeout ID to prevent multiple timeouts
                            if (sprite.animationTimeout) {
                                console.log(`üé¨ [${timestamp}] ‚ö†Ô∏è Clearing existing timeout for ${playerId}`);
                                clearTimeout(sprite.animationTimeout);
                            }
                            
                            // Return to idle frame (frame 0) after movement animation completes
                            sprite.animationTimeout = setTimeout(() => {
                                if (sprite && sprite.active) {
                                    const endTimestamp = Date.now();
                                    console.log(`üé¨ [${endTimestamp}] üî¥ STOPPING animation for ${playerId} after ${endTimestamp - timestamp}ms - setting isWalking=false`);
                                    sprite.stop(); // Stop the walking animation
                                    sprite.setFrame(0); // Set to idle frame (still character)
                                    sprite.isWalking = false;
                                    sprite.animationTimeout = null;
                                }
                            }, 500); // 500ms walking animation duration
                        } else if (positionChanged && sprite.isWalking) {
                            console.log(`üé¨ [${timestamp}] ‚ö†Ô∏è ${playerId} position changed while already animating - IGNORING (preventing double animation)`);
                        } else if (!positionChanged) {
                            console.log(`üé¨ [${timestamp}] ${playerId} no position change detected - no animation needed`);
                        }
                        
                        // Handle sprite flipping based on movement direction
                        if (player.lastMoveDirection) {
                            console.log(`üîÑ ${playerId} handling flip: ${player.lastMoveDirection}`);
                            switch (player.lastMoveDirection) {
                                case 'left':
                                    // Flip sprite to face left
                                    sprite.setFlipX(true);
                                    break;
                                case 'right':
                                    // Face normal direction (right)
                                    sprite.setFlipX(false);
                                    break;
                                case 'up':
                                case 'down':
                                    // Keep current flip state for up/down movement
                                    // Don't change flip - character maintains last left/right direction
                                    break;
                            }
                        }
                    }
                    
                    // Calculate sprite positioning with proper offset handling for flipped sprites
                    const scale = (coords.tileSize * 2.0) / 64;
                    const baseOffsetY = -20 * scale; // Base vertical offset (same for both directions)
                    
                    // Adjust horizontal offset based on flip state
                    let baseOffsetX;
                    if (sprite.flipX) {
                        // When flipped (facing left), offset needs to be positive to center properly
                        baseOffsetX = 16 * scale; // Move right to center horizontally
                    } else {
                        // When not flipped (facing right), use negative offset as before
                        baseOffsetX = -16 * scale; // Move left to center horizontally
                    }
                    
                    // Apply final position with corrected offset
                    const spriteX = coords.x + baseOffsetX;
                    const spriteY = coords.y + baseOffsetY;
                    
                    sprite.setPosition(spriteX, spriteY);
                    label.setPosition(coords.x, coords.y - 40); // Label stays above tile center
                    
                    // Highlight current player's turn - only highlight the text label
                    if (serverGameState.gameStarted && serverGameState.currentPlayerTurn === playerId) {
                        // Highlight the player label with bright yellow and bold text
                        label.setStyle({ fontSize: '16px', fill: '#ffff00', fontWeight: 'bold', stroke: '#000000', strokeThickness: 3 });
                    } else {
                        // Normal appearance for waiting player label
                        label.setStyle({ fontSize: '12px', fill: '#ffffff', fontWeight: 'normal', stroke: '#000000', strokeThickness: 2 });
                    }
                    
                    // Special victory effects for player sprites
                    if (serverGameState.gameCompleted) {
                        if (sprite.setStrokeStyle) {
                            sprite.setScale(1.3); // Make both players even larger for final victory
                            sprite.setStrokeStyle(5, 0xff6b35); // Bright orange border for final victory
                        } else {
                            const baseScale = (coords.tileSize * 2.0) / 64;
                            sprite.setScale(baseScale * 1.3);
                            sprite.setTint(0xff6b35); // Orange tint for victory
                        }
                        label.setStyle({ fontSize: '18px', fill: '#ff6b35', fontWeight: 'bold' }); // Orange final victory labels
                    } else if (serverGameState.gameWon) {
                        if (sprite.setStrokeStyle) {
                            sprite.setScale(1.2); // Make both players larger
                            sprite.setStrokeStyle(4, 0xffd700); // Gold border for victory
                        } else {
                            const baseScale = (coords.tileSize * 2.0) / 64;
                            sprite.setScale(baseScale * 1.2);
                            sprite.setTint(0xffd700); // Gold tint for victory
                        }
                        label.setStyle({ fontSize: '16px', fill: '#ffd700', fontWeight: 'bold' }); // Gold victory labels
                    }
                }
            }
        }

        // Function to set up keyboard input
        function setupKeyboardInput(scene) {
            // Set up individual key listeners for immediate response
            scene.input.keyboard.on('keydown-UP', () => sendMoveRequest('up'));
            scene.input.keyboard.on('keydown-DOWN', () => sendMoveRequest('down'));
            scene.input.keyboard.on('keydown-LEFT', () => sendMoveRequest('left'));
            scene.input.keyboard.on('keydown-RIGHT', () => sendMoveRequest('right'));
            scene.input.keyboard.on('keydown-SPACE', () => sendUseItemRequest());
        }



        // Function to send move requests to server
        function sendMoveRequest(direction) {
            try {
                if (!myPlayerId || !serverGameState) {
                    console.log('Cannot move: not connected or no player ID');
                    return;
                }
                
                if (serverGameState.gameWon || serverGameState.gameCompleted) {
                    console.log('Cannot move: game completed!');
                    return;
                }
                
                if (!direction || typeof direction !== 'string') {
                    console.error('‚ùå Invalid direction for move request:', direction);
                    return;
                }
                
                // Don't trigger animation immediately - wait for server confirmation
                // This prevents double animation triggering
                
                console.log('Sending move request:', direction);
                socket.emit('moveRequest', { direction: direction });
                
            } catch (error) {
                console.error('‚ùå Error sending move request:', error);
            }
        }

        // Function to send use item requests to server
        function sendUseItemRequest() {
            try {
                if (!myPlayerId || !serverGameState) {
                    console.log('Cannot use item: not connected or no player ID');
                    return;
                }
                
                if (serverGameState.gameWon || serverGameState.gameCompleted) {
                    console.log('Cannot use item: game completed!');
                    return;
                }
                
                if (!serverGameState.gameStarted) {
                    console.log('Cannot use item: game not started');
                    return;
                }
                
                if (serverGameState.currentPlayerTurn !== myPlayerId) {
                    console.log('Cannot use item: not your turn');
                    return;
                }
                
                if (!serverGameState.yourItem) {
                    console.log('Cannot use item: no item assigned');
                    return;
                }
                
                console.log('Sending use item request:', serverGameState.yourItem);
                socket.emit('useItemRequest', { item: serverGameState.yourItem });
                
            } catch (error) {
                console.error('‚ùå Error sending use item request:', error);
            }
        }

        function update() {
            // Game loop (empty for now)
        }

        // Initialize the game
        const game = new Phaser.Game(config);
    </script>
</body>
</html> 