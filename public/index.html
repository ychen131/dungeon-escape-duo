<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dungeon Escape Duo</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #2c3e50;
            font-family: Arial, sans-serif;
        }
        
        /* Victory screen animations */
        @keyframes victory-pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .victory-animation {
            animation: victory-pulse 2s ease-in-out infinite;
        }
        
        @keyframes gradient-shift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        #game-container {
            text-align: center;
        }
        h1 {
            color: #ecf0f1;
            margin-bottom: 20px;
        }
        #status {
            color: #ecf0f1;
            margin-top: 20px;
            font-size: 16px;
            transition: all 0.3s ease; /* Smooth transitions for turn changes */
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <h1>Dungeon Escape Duo</h1>
        <div id="game"></div>
        <div id="status">Connecting to server...</div>
        <div id="item-display" style="text-align: center;"></div>
    </div>

    <!-- Phaser 3 Library via CDN -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    
    <!-- Socket.io Client Library -->
    <script src="/socket.io/socket.io.js"></script>
    
    <script>
        // Socket.io connection
        const socket = io();
        
        // Game state received from server
        let serverGameState = null;
        let myPlayerId = null;
        let gameInitialized = false;
        let connectionRejected = false;
        
        // Grid configuration
        const TILE_SIZE = 50;
        
        // References to game objects
        let gameScene = null;
        let playerSprites = {};
        let gridTiles = []; // Track grid tiles for clearing
        let statusElement = document.getElementById('status');
        let itemDisplayElement = document.getElementById('item-display');
        
        // Socket event handlers
        socket.on('connect', () => {
            console.log('Connected to server');
            statusElement.textContent = 'Connected! Waiting for game state...';
        });
        
        socket.on('disconnect', () => {
            console.log('Disconnected from server');
            if (!connectionRejected) {
                statusElement.textContent = 'Disconnected from server';
            }
        });
        
        socket.on('connectionRejected', (data) => {
            console.log('Connection rejected:', data.reason);
            connectionRejected = true;
            statusElement.textContent = `Connection rejected: ${data.reason}`;
            statusElement.style.color = '#e74c3c'; // Red color for error
        });
        
        socket.on('gameState', (newGameState) => {
            try {
                console.log('Received game state:', newGameState);
                
                // Validate game state structure
                if (!newGameState || typeof newGameState !== 'object') {
                    console.error('‚ùå Invalid game state received:', newGameState);
                    statusElement.textContent = '‚ùå Connection error - invalid game state';
                    statusElement.style.color = '#e74c3c';
                    return;
                }
                
                // Store the new game state
                serverGameState = newGameState;
            
            // If this is the initial game state, store our player ID
            if (newGameState.yourPlayerId) {
                myPlayerId = newGameState.yourPlayerId;
                console.log('Assigned as:', myPlayerId);
            }
            
                         // Update status
             const playerCount = Object.keys(newGameState.players).length;
             
                           // Check for level transition first
              if (newGameState.levelTransition && newGameState.levelTransition.isTransitioning) {
                  const toLevel = newGameState.levelTransition.toLevel;
                  statusElement.textContent = `üöÄ ENTERING LEVEL ${toLevel} üöÄ`;
                  statusElement.style.color = '#3498db'; // Blue for transition
                  statusElement.style.fontSize = '24px';
                  statusElement.style.fontWeight = 'bold';
                  statusElement.style.textShadow = '0 0 20px rgba(52, 152, 219, 0.8)'; // Blue glow
                  statusElement.style.textAlign = 'center';
                  statusElement.className = 'victory-animation'; // Reuse pulsing animation
                  
                  itemDisplayElement.textContent = `üéØ Prepare for greater challenges! New puzzles await... üéØ`;
                  itemDisplayElement.style.color = '#9b59b6'; // Purple for mystery
                  itemDisplayElement.style.fontSize = '16px';
                  itemDisplayElement.style.fontWeight = 'bold';
                  itemDisplayElement.style.textAlign = 'center';
                  
                  // Add transition background effect
                  document.getElementById('game-container').style.background = 'linear-gradient(45deg, #3498db, #9b59b6, #3498db)';
                  document.getElementById('game-container').style.backgroundSize = '300% 300%';
                  document.getElementById('game-container').style.animation = 'gradient-shift 2s ease infinite';
                  
              // Check for win condition
              } else if (newGameState.gameWon) {
                  // Create elaborate victory display
                  const levelName = newGameState.levelProgression === 1 ? "Level 1" : newGameState.levelProgression === 2 ? "Level 2" : `Level ${newGameState.levelProgression}`;
                  const isMaxLevel = newGameState.levelProgression >= 2;
                  
                  if (isMaxLevel) {
                      statusElement.textContent = `üèÜ CONGRATULATIONS! YOU MASTERED THE DUNGEON! üèÜ`;
                      itemDisplayElement.textContent = `üéâ Both players completed ${levelName}! üéâ | You worked perfectly together!`;
                  } else {
                      statusElement.textContent = `üéâ VICTORY! ${levelName.toUpperCase()} COMPLETE! üéâ`;
                      itemDisplayElement.textContent = `üåü Excellent teamwork! Advancing to ${levelName === "Level 1" ? "Level 2" : "Level 3"} in 5 seconds... üåü`;
                  }
                  
                  statusElement.style.color = '#f1c40f'; // Golden yellow for victory
                  statusElement.style.fontSize = '22px';
                  statusElement.style.fontWeight = 'bold';
                  statusElement.style.textShadow = '0 0 15px rgba(241, 196, 15, 0.8)'; // Golden glow
                  statusElement.style.textAlign = 'center';
                  statusElement.className = 'victory-animation'; // Add pulsing animation
                  
                  itemDisplayElement.style.color = '#27ae60'; // Green for celebration
                  itemDisplayElement.style.fontSize = '16px';
                  itemDisplayElement.style.fontWeight = 'bold';
                  itemDisplayElement.style.textAlign = 'center';
                  
                  // Add celebration confetti effect to the game container
                  document.getElementById('game-container').style.background = 'linear-gradient(45deg, #2c3e50, #34495e, #2c3e50)';
                  document.getElementById('game-container').style.backgroundSize = '200% 200%';
                  document.getElementById('game-container').style.animation = 'gradient-shift 3s ease infinite';
                            } else if (playerCount === 1) {
                  // Check if there was a disconnection vs fresh start
                  if (newGameState.disconnectedPlayer) {
                      const disconnectedPlayerId = newGameState.disconnectedPlayer.playerId.toUpperCase();
                      statusElement.textContent = `‚ö†Ô∏è ${disconnectedPlayerId} disconnected! Waiting for reconnection... You are ${myPlayerId}`;
                      statusElement.style.color = '#e74c3c'; // Red for disconnection
                      itemDisplayElement.textContent = `Game paused at Level ${newGameState.levelProgression} | ${disconnectedPlayerId} has 30 seconds to reconnect`;
                  } else {
                      statusElement.textContent = `‚è≥ Waiting for partner to join... You are ${myPlayerId}`;
                      statusElement.style.color = '#f39c12'; // Orange for waiting
                      itemDisplayElement.textContent = `Level ${newGameState.levelProgression} - ${newGameState.currentLevel.toUpperCase()} Layout ${newGameState.mapIndex + 1} | Partner needed to continue`;
                  }
                  
                  statusElement.style.fontSize = '18px';
                  statusElement.style.fontWeight = 'bold';
                  statusElement.className = ''; // Remove any victory animations
                  statusElement.style.textShadow = 'none';
                  itemDisplayElement.style.color = statusElement.style.color;
                  
                  // Reset background for non-victory states
                  document.getElementById('game-container').style.background = 'none';
                  document.getElementById('game-container').style.animation = 'none';
             } else if (playerCount === 2) {
                 if (newGameState.gameStarted) {
                     const isMyTurn = newGameState.currentPlayerTurn === myPlayerId;
                     
                     if (isMyTurn) {
                         statusElement.textContent = `üü¢ YOUR TURN | You are ${myPlayerId} | Arrow keys: move, SPACE: use item`;
                         statusElement.style.color = '#2ecc71'; // Bright green for your turn
                         statusElement.style.fontSize = '18px';
                         statusElement.style.fontWeight = 'bold';
                         statusElement.style.textShadow = '0 0 10px rgba(46, 204, 113, 0.5)'; // Subtle glow effect
                     } else {
                         const otherPlayer = newGameState.currentPlayerTurn.toUpperCase();
                         statusElement.textContent = `‚è≥ ${otherPlayer}'S TURN | You are ${myPlayerId} | Wait for your partner...`;
                         statusElement.style.color = '#f39c12'; // Orange for waiting
                                               statusElement.style.fontSize = '16px';
                      statusElement.style.fontWeight = 'normal';
                      statusElement.style.textShadow = 'none';
                      statusElement.className = ''; // Remove victory animations
                     }
                     
                     // Update item display
                     if (newGameState.yourItem) {
                         itemDisplayElement.textContent = `Your Item: ${newGameState.yourItem} | Level ${newGameState.levelProgression} - ${newGameState.currentLevel.toUpperCase()} Layout ${newGameState.mapIndex + 1}`;
                         itemDisplayElement.style.color = '#3498db'; // Blue for item
                     } else {
                         itemDisplayElement.textContent = `Level ${newGameState.levelProgression} - ${newGameState.currentLevel.toUpperCase()} Layout ${newGameState.mapIndex + 1}`;
                         itemDisplayElement.style.color = '#95a5a6'; // Grey for map info
                     }
                 } else {
                     statusElement.textContent = `üöÄ Both players ready! You are ${myPlayerId}. Game starting...`;
                                           statusElement.style.color = '#2ecc71'; // Green for ready
                      statusElement.style.fontSize = '18px';
                      statusElement.style.fontWeight = 'bold';
                      statusElement.className = ''; // Remove victory animations
                      statusElement.style.textShadow = 'none';
                      itemDisplayElement.textContent = `Level ${newGameState.levelProgression} - ${newGameState.currentLevel.toUpperCase()} Layout ${newGameState.mapIndex + 1} | Get ready to cooperate!`;
                      itemDisplayElement.style.color = '#2ecc71';
                      
                      // Reset background for normal game states
                      document.getElementById('game-container').style.background = 'none';
                      document.getElementById('game-container').style.animation = 'none';
                 }
             }
            
                // Initialize or update the game rendering
                if (gameInitialized && gameScene) {
                    updateGameRendering();
                } else if (!gameInitialized && newGameState.dungeonLayout) {
                    initializeGame();
                }
                
            } catch (gameStateError) {
                console.error('‚ùå Error processing game state:', gameStateError);
                statusElement.textContent = '‚ùå Game rendering error - please refresh';
                statusElement.style.color = '#e74c3c';
            }
        });

        // Handle game errors from server
        socket.on('gameError', (errorData) => {
            console.error('‚ùå Game error from server:', errorData);
            statusElement.textContent = `‚ùå Game Error: ${errorData.message}`;
            statusElement.style.color = '#e74c3c';
            statusElement.style.fontSize = '16px';
            statusElement.style.fontWeight = 'bold';
        });

        // Phaser 3 Game Configuration
        const config = {
            type: Phaser.AUTO,
            width: 800,
            height: 600,
            parent: 'game',
            backgroundColor: '#34495e',
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        // Phaser 3 Scene Functions
        function preload() {
            // Preload assets (none for now)
        }

        function create() {
            gameScene = this;
            
            // Add game title above the grid
            this.add.text(400, 50, 'Dungeon Escape Duo', {
                fontSize: '24px',
                fill: '#ecf0f1'
            }).setOrigin(0.5);
            
            // Set up keyboard input
            setupKeyboardInput(this);
            
            // If we already have game state, render it
            if (serverGameState) {
                renderInitialGame();
            }
        }

        function initializeGame() {
            if (!serverGameState || gameInitialized) return;
            
            console.log('Initializing game with server state');
            gameInitialized = true;
            
            // If the Phaser scene is ready, render immediately
            if (gameScene) {
                renderInitialGame();
            }
        }

        function renderInitialGame() {
            if (!gameScene || !serverGameState) return;
            
            // Clear any existing game objects
            gameScene.children.removeAll();
            playerSprites = {};
            gridTiles = []; // Clear grid tiles array
            
            // Re-add title
            gameScene.add.text(400, 50, 'Dungeon Escape Duo', {
                fontSize: '24px',
                fill: '#ecf0f1'
            }).setOrigin(0.5);
            
            // Render the dungeon grid
            renderDungeonGrid();
            
            // Create player sprites
            createPlayerSprites();
            
            // Update status
            updateGameRendering();
        }

        function renderDungeonGrid() {
            try {
                if (!gameScene || !serverGameState) {
                    console.warn('‚ö†Ô∏è  Cannot render grid: missing scene or game state');
                    return;
                }
                
                if (!serverGameState.dungeonLayout || !Array.isArray(serverGameState.dungeonLayout)) {
                    console.error('‚ùå Invalid dungeon layout:', serverGameState.dungeonLayout);
                    return;
                }
            
            // Clear existing grid tiles
            gridTiles.forEach(tile => tile.destroy());
            gridTiles = [];
            
            const dungeonLayout = serverGameState.dungeonLayout;
            const gridWidth = serverGameState.gridWidth;
            const gridHeight = serverGameState.gridHeight;
            
            // Calculate starting position to center the grid
            const startX = (800 - (gridWidth * TILE_SIZE)) / 2;
            const startY = (600 - (gridHeight * TILE_SIZE)) / 2;
            
            // Loop through each row
            for (let row = 0; row < gridHeight; row++) {
                // Loop through each column
                for (let col = 0; col < gridWidth; col++) {
                    // Get the tile type from the dungeon layout
                    const tileType = dungeonLayout[row][col];
                    
                    // Calculate pixel position
                    const x = startX + (col * TILE_SIZE);
                    const y = startY + (row * TILE_SIZE);
                    
                                         // Choose color based on tile type
                     let color;
                     if (tileType === 0) {
                         color = 0x95a5a6; // Light grey for floor tiles
                     } else if (tileType === 1) {
                         color = 0x2c3e50; // Dark grey for wall tiles
                     } else if (tileType === 2) {
                         color = 0xe74c3c; // Red for fire hazard
                     } else if (tileType === 3) {
                         color = 0x8e44ad; // Purple for chasm
                     } else if (tileType === 4) {
                         color = 0x27ae60; // Green for exit tiles
                     }
                    
                    // Create a rectangle for this tile
                    const tile = gameScene.add.rectangle(x, y, TILE_SIZE - 2, TILE_SIZE - 2, color);
                    tile.setOrigin(0, 0);
                    gridTiles.push(tile); // Track for clearing later
                    
                    // Add a subtle border effect
                    const border = gameScene.add.rectangle(x, y, TILE_SIZE, TILE_SIZE);
                    border.setStrokeStyle(1, 0x34495e);
                    border.setOrigin(0, 0);
                    border.setFillStyle();
                    gridTiles.push(border); // Track for clearing later
                }
            }
            
            } catch (error) {
                console.error('‚ùå Error rendering dungeon grid:', error);
                statusElement.textContent = '‚ùå Rendering error - please refresh';
                statusElement.style.color = '#e74c3c';
            }
        }

        function createPlayerSprites() {
            if (!gameScene || !serverGameState) return;
            
            const startX = (800 - (serverGameState.gridWidth * TILE_SIZE)) / 2;
            const startY = (600 - (serverGameState.gridHeight * TILE_SIZE)) / 2;
            
            // Create sprites for all players
            for (const [playerId, player] of Object.entries(serverGameState.players)) {
                const pixelX = startX + (player.x * TILE_SIZE) + (TILE_SIZE / 2);
                const pixelY = startY + (player.y * TILE_SIZE) + (TILE_SIZE / 2);
                
                // Different colors for different players
                const color = playerId === 'player1' ? 0x3498db : 0xe74c3c; // Blue for P1, Red for P2
                
                const sprite = gameScene.add.rectangle(pixelX, pixelY, TILE_SIZE - 10, TILE_SIZE - 10, color);
                sprite.setStrokeStyle(2, 0xffffff);
                sprite.setDepth(100);
                
                playerSprites[playerId] = sprite;
                
                // Add label above player
                const label = gameScene.add.text(pixelX, pixelY - 30, playerId.toUpperCase(), {
                    fontSize: '12px',
                    fill: '#ffffff'
                }).setOrigin(0.5);
                label.setDepth(101);
                
                playerSprites[playerId + '_label'] = label;
            }
        }

        function updateGameRendering() {
            if (!gameScene || !serverGameState) return;
            
            // Re-render the entire grid to show tile changes (like fire being doused)
            renderDungeonGrid();
            
            const startX = (800 - (serverGameState.gridWidth * TILE_SIZE)) / 2;
            const startY = (600 - (serverGameState.gridHeight * TILE_SIZE)) / 2;
            
            // Check for new players and create sprites for them
            for (const [playerId, player] of Object.entries(serverGameState.players)) {
                if (!playerSprites[playerId]) {
                    // New player detected - create sprite and label
                    const pixelX = startX + (player.x * TILE_SIZE) + (TILE_SIZE / 2);
                    const pixelY = startY + (player.y * TILE_SIZE) + (TILE_SIZE / 2);
                    
                    // Different colors for different players
                    const color = playerId === 'player1' ? 0x3498db : 0xe74c3c; // Blue for P1, Red for P2
                    
                    const sprite = gameScene.add.rectangle(pixelX, pixelY, TILE_SIZE - 10, TILE_SIZE - 10, color);
                    sprite.setStrokeStyle(2, 0xffffff);
                    sprite.setDepth(100);
                    
                    playerSprites[playerId] = sprite;
                    
                    // Add label above player
                    const label = gameScene.add.text(pixelX, pixelY - 30, playerId.toUpperCase(), {
                        fontSize: '12px',
                        fill: '#ffffff'
                    }).setOrigin(0.5);
                    label.setDepth(101);
                    
                    playerSprites[playerId + '_label'] = label;
                    
                    console.log(`Created sprite for new player: ${playerId}`);
                }
            }
            
            // Remove sprites for players who have disconnected
            for (const spriteKey of Object.keys(playerSprites)) {
                if (spriteKey.endsWith('_label')) continue; // Skip labels, handle them with their player
                
                const playerId = spriteKey;
                if (!serverGameState.players[playerId]) {
                    // Player has disconnected - remove sprite and label
                    if (playerSprites[playerId]) {
                        playerSprites[playerId].destroy();
                        delete playerSprites[playerId];
                    }
                    if (playerSprites[playerId + '_label']) {
                        playerSprites[playerId + '_label'].destroy();
                        delete playerSprites[playerId + '_label'];
                    }
                    console.log(`Removed sprite for disconnected player: ${playerId}`);
                }
            }
            
            // Update positions for all existing players
            for (const [playerId, player] of Object.entries(serverGameState.players)) {
                const sprite = playerSprites[playerId];
                const label = playerSprites[playerId + '_label'];
                
                if (sprite && label) {
                    const pixelX = startX + (player.x * TILE_SIZE) + (TILE_SIZE / 2);
                    const pixelY = startY + (player.y * TILE_SIZE) + (TILE_SIZE / 2);
                    
                    sprite.setPosition(pixelX, pixelY);
                    label.setPosition(pixelX, pixelY - 30);
                    
                    // Highlight current player's turn with visual effects
                    if (serverGameState.gameStarted && serverGameState.currentPlayerTurn === playerId) {
                        // Make current player's sprite more prominent
                        sprite.setScale(1.1); // Slightly larger
                        sprite.setStrokeStyle(3, 0xffff00); // Yellow glow
                        label.setStyle({ fontSize: '14px', fill: '#ffff00', fontWeight: 'bold' }); // Yellow label
                                         } else {
                         // Normal appearance for waiting player
                         sprite.setScale(1.0);
                         sprite.setStrokeStyle(2, 0xffffff); // White border
                         label.setStyle({ fontSize: '12px', fill: '#ffffff', fontWeight: 'normal' }); // White label
                     }
                     
                     // Special victory effects for player sprites
                     if (serverGameState.gameWon) {
                         sprite.setScale(1.2); // Make both players larger
                         sprite.setStrokeStyle(4, 0xffd700); // Gold border for victory
                         label.setStyle({ fontSize: '16px', fill: '#ffd700', fontWeight: 'bold' }); // Gold victory labels
                     }
                }
            }
        }

        // Function to set up keyboard input
        function setupKeyboardInput(scene) {
            // Set up individual key listeners for immediate response
            scene.input.keyboard.on('keydown-UP', () => sendMoveRequest('up'));
            scene.input.keyboard.on('keydown-DOWN', () => sendMoveRequest('down'));
            scene.input.keyboard.on('keydown-LEFT', () => sendMoveRequest('left'));
            scene.input.keyboard.on('keydown-RIGHT', () => sendMoveRequest('right'));
            scene.input.keyboard.on('keydown-SPACE', () => sendUseItemRequest());
        }

        // Function to send move requests to server
        function sendMoveRequest(direction) {
            try {
                if (!myPlayerId || !serverGameState) {
                    console.log('Cannot move: not connected or no player ID');
                    return;
                }
                
                if (serverGameState.gameWon) {
                    console.log('Cannot move: game already won!');
                    return;
                }
                
                if (!direction || typeof direction !== 'string') {
                    console.error('‚ùå Invalid direction for move request:', direction);
                    return;
                }
                
                console.log('Sending move request:', direction);
                socket.emit('moveRequest', { direction: direction });
                
            } catch (error) {
                console.error('‚ùå Error sending move request:', error);
            }
        }

        // Function to send use item requests to server
        function sendUseItemRequest() {
            try {
                if (!myPlayerId || !serverGameState) {
                    console.log('Cannot use item: not connected or no player ID');
                    return;
                }
                
                if (serverGameState.gameWon) {
                    console.log('Cannot use item: game already won!');
                    return;
                }
                
                if (!serverGameState.gameStarted) {
                    console.log('Cannot use item: game not started');
                    return;
                }
                
                if (serverGameState.currentPlayerTurn !== myPlayerId) {
                    console.log('Cannot use item: not your turn');
                    return;
                }
                
                if (!serverGameState.yourItem) {
                    console.log('Cannot use item: no item assigned');
                    return;
                }
                
                console.log('Sending use item request:', serverGameState.yourItem);
                socket.emit('useItemRequest', { item: serverGameState.yourItem });
                
            } catch (error) {
                console.error('‚ùå Error sending use item request:', error);
            }
        }

        function update() {
            // Game loop (empty for now)
        }

        // Initialize the game
        const game = new Phaser.Game(config);
    </script>
</body>
</html> 